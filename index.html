<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lovable AI PDF Tools</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Libraries -->
    <!-- pdf-lib for manipulation -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <!-- pdf.js for viewing/rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- JSZip for zipping images -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- FileSaver for saving Zip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <script>
        // Set worker source for pdf.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f8f8;
        }

        /* Glassmorphism */
        .glass-light {
            background-color: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        .dark .glass-dark {
            background-color: rgba(30, 30, 35, 0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Dark mode base */
        .dark body {
            background-color: #111113;
        }
        
        /* Buttons */
        .btn-glass {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            border-radius: 9999px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .btn-glass:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        .btn-glass:active {
            transform: scale(0.98);
        }
        
        /* Grid & Cards */
        .tool-card {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .tool-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
        }

        /* Page Preview Styles */
        .page-container {
            position: relative;
            transition: all 0.2s ease;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .page-container canvas {
            display: block;
            width: 100%;
            height: auto;
        }
        .page-container:hover .page-overlay {
            opacity: 1;
        }
        .page-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        /* Selected State */
        .page-container.selected {
            outline: 4px solid #3b82f6;
            transform: scale(0.95);
        }
        .page-container.selected::after {
            content: '‚úì';
            position: absolute;
            top: 8px;
            right: 8px;
            background: #3b82f6;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        /* Deleted State */
        .page-container.deleted {
            opacity: 0.4;
            filter: grayscale(100%);
        }
        .page-container.deleted::after {
            content: 'REMOVED';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-45deg);
            color: #ef4444;
            font-weight: 800;
            font-size: 1.2rem;
            border: 2px solid #ef4444;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.8);
        }
    </style>
</head>

<body class="text-gray-900 dark:text-gray-100 min-h-screen transition-colors duration-300">

    <!-- Header -->
    <header class="sticky top-0 z-40 w-full glass-light dark:glass-dark shadow-sm">
        <div class="container mx-auto px-4 h-16 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <svg class="w-8 h-8 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                <span class="text-xl font-bold">Complete PDF Tools</span>
            </div>
            <button id="dark-mode-toggle" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors">
                <svg id="theme-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
            </button>
        </div>
    </header>

    <!-- Main -->
    <main class="container mx-auto px-4 py-12">
        <!-- H1 removed as requested -->
        <p class="text-center text-gray-500 mb-12">100% free. Secure. Fast.</p>
        
        <div id="tools-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-6 max-w-6xl mx-auto">
            <!-- Tools injected JS -->
        </div>
    </main>

    <!-- Modal -->
    <div id="tool-modal" class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 z-50 hidden">
        <div class="glass-light dark:glass-dark w-full max-w-5xl h-[90vh] rounded-2xl shadow-2xl flex flex-col overflow-hidden animate-scale-in">
            
            <!-- Header -->
            <div class="flex justify-between items-center p-5 border-b border-gray-200 dark:border-gray-700">
                <h3 id="modal-title" class="text-xl font-semibold">Tool</h3>
                <button onclick="closeModal()" class="text-gray-400 hover:text-red-500 transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>

            <!-- Content Area (Scrollable) -->
            <div class="flex-1 overflow-y-auto p-6 bg-gray-50/50 dark:bg-gray-900/50">
                
                <!-- Upload Section -->
                <div id="upload-section" class="max-w-xl mx-auto mt-10">
                    <div id="drop-zone" class="border-2 border-dashed border-gray-400 rounded-xl p-12 text-center hover:border-blue-500 transition-colors cursor-pointer">
                        <svg class="w-16 h-16 mx-auto text-blue-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                        <p id="upload-text" class="text-lg font-medium">Click or Drag PDF files here</p>
                        <input type="file" id="file-input" class="hidden" accept=".pdf">
                    </div>
                </div>

                <!-- Preview Grid -->
                <div id="preview-container" class="hidden">
                    <div class="flex justify-between items-center mb-6">
                        <h4 class="text-lg font-medium">Pages (<span id="page-count">0</span>)</h4>
                        <div class="text-sm text-gray-500" id="preview-instruction">Select pages to edit</div>
                    </div>
                    
                    <!-- Grid of Canvas elements -->
                    <div id="pages-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4"></div>
                </div>

                <!-- Global Options -->
                <div id="global-options" class="hidden max-w-xl mx-auto mt-6 space-y-4">
                    <!-- Injected by JS -->
                </div>

                <!-- Loading/Processing State -->
                <div id="processing-overlay" class="hidden absolute inset-0 bg-white/80 dark:bg-gray-900/80 flex flex-col items-center justify-center z-10">
                    <div class="w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-4"></div>
                    <p id="processing-text" class="font-medium">Processing...</p>
                </div>
            </div>

            <!-- Footer -->
            <div class="p-5 border-t border-gray-200 dark:border-gray-700 bg-white/50 dark:bg-gray-800/50 flex justify-end gap-3">
                <button onclick="closeModal()" class="px-6 py-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors font-medium">Cancel</button>
                <button id="process-btn" class="btn-glass bg-blue-600 text-white px-8 py-2 font-semibold disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    Process & Download
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Data & Config ---
        const tools = [
            { id: 'rotate', name: 'Rotate PDF', icon: 'üîÑ', color: 'text-blue-500', mode: 'edit', accept: '.pdf' },
            { id: 'delete', name: 'Delete Pages', icon: 'üóëÔ∏è', color: 'text-red-500', mode: 'edit', accept: '.pdf' },
            { id: 'split', name: 'Split / Extract', icon: '‚úÇÔ∏è', color: 'text-green-500', mode: 'select', accept: '.pdf' },
            { id: 'merge', name: 'Merge PDF', icon: 'üîó', color: 'text-yellow-500', mode: 'view', multiple: true, accept: '.pdf' },
            { id: 'pdfToJpg', name: 'PDF to JPG', icon: 'üñºÔ∏è', color: 'text-pink-500', mode: 'select', accept: '.pdf', isNew: true },
            { id: 'pdfToText', name: 'PDF to Text', icon: 'üìù', color: 'text-slate-500', mode: 'view', accept: '.pdf', isNew: true },
            { id: 'txtToPdf', name: 'Text to PDF', icon: 'üìÑ', color: 'text-indigo-500', mode: 'view', accept: '.txt', isNew: true },
            { id: 'protect', name: 'Protect PDF', icon: 'üîí', color: 'text-purple-500', mode: 'view', accept: '.pdf' },
            { id: 'unlock', name: 'Unlock PDF', icon: 'üîì', color: 'text-orange-500', mode: 'view', accept: '.pdf' },
            { id: 'watermark', name: 'Add Watermark', icon: 'üíß', color: 'text-blue-400', mode: 'view', accept: '.pdf' },
            { id: 'pageNumber', name: 'Page Numbers', icon: 'üî¢', color: 'text-gray-500', mode: 'view', accept: '.pdf' }
        ];

        let currentTool = null;
        let currentFile = null; // For single file ops
        let currentFiles = [];  // For merge
        let pdfDocProxy = null; // pdf.js document
        let pageStates = []; // { rotation: 0, deleted: false, selected: false }

        // --- UI Initialization ---
        const grid = document.getElementById('tools-grid');
        tools.forEach(tool => {
            grid.innerHTML += `
                <div onclick="openTool('${tool.id}')" class="tool-card glass-light dark:glass-dark p-6 rounded-2xl text-center cursor-pointer relative">
                    <div class="text-4xl mb-4">${tool.icon}</div>
                    <h3 class="font-semibold ${tool.color}">${tool.name}</h3>
                    ${tool.isNew ? '<span class="absolute top-2 right-2 bg-red-500 text-white text-xs px-2 py-1 rounded-full animate-pulse">NEW</span>' : ''}
                </div>
            `;
        });

        // --- Modal Logic ---
        const modal = document.getElementById('tool-modal');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        
        function openTool(id) {
            currentTool = tools.find(t => t.id === id);
            document.getElementById('modal-title').textContent = currentTool.name;
            modal.classList.remove('hidden');
            
            // Reset
            document.getElementById('upload-section').classList.remove('hidden');
            document.getElementById('preview-container').classList.add('hidden');
            document.getElementById('global-options').classList.add('hidden');
            document.getElementById('process-btn').disabled = true;
            document.getElementById('pages-grid').innerHTML = '';
            pageStates = [];
            currentFile = null;
            currentFiles = [];
            
            fileInput.multiple = !!currentTool.multiple;
            fileInput.accept = currentTool.accept;
            document.getElementById('upload-text').textContent = `Click or Drag ${currentTool.accept.toUpperCase().replace('.', '')} files here`;
            
            // Instructions
            const instr = document.getElementById('preview-instruction');
            if(currentTool.id === 'rotate') instr.textContent = "Click buttons to rotate individual pages.";
            else if(currentTool.id === 'delete') instr.textContent = "Click trash icon to remove pages.";
            else if(currentTool.id === 'split') instr.textContent = "Click pages to KEEP them. Unselected pages will be removed.";
            else if(currentTool.id === 'pdfToJpg') instr.textContent = "Select pages to convert to Images.";
            else instr.textContent = "Review your document.";
        }

        function closeModal() {
            modal.classList.add('hidden');
        }

        // --- File Handling ---
        dropZone.onclick = () => fileInput.click();
        dropZone.ondragover = (e) => { e.preventDefault(); dropZone.classList.add('border-blue-500'); };
        dropZone.ondragleave = (e) => { e.preventDefault(); dropZone.classList.remove('border-blue-500'); };
        dropZone.ondrop = (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-blue-500');
            handleFiles(e.dataTransfer.files);
        };
        fileInput.onchange = (e) => handleFiles(e.target.files);

        async function handleFiles(files) {
            if (!files.length) return;
            
            document.getElementById('upload-section').classList.add('hidden');
            document.getElementById('processing-overlay').classList.remove('hidden');
            document.getElementById('processing-text').textContent = "Loading...";

            try {
                if (currentTool.id === 'txtToPdf') {
                    // Special Handler for Text to PDF
                    await handleTextToPdf(files[0]);
                } else if (currentTool.multiple) {
                    currentFiles = Array.from(files);
                    renderSimpleFileList(); 
                } else {
                    currentFile = files[0];
                    const arrayBuffer = await currentFile.arrayBuffer();
                    
                    // Handle Password Protected files
                    try {
                        pdfDocProxy = await pdfjsLib.getDocument(arrayBuffer).promise;
                    } catch (e) {
                        if (e.name === 'PasswordException') {
                             const password = prompt("This PDF is password protected. Please enter the password:");
                             pdfDocProxy = await pdfjsLib.getDocument({ data: arrayBuffer, password: password }).promise;
                        } else {
                            throw e;
                        }
                    }
                    
                    await renderPreviewGrid(pdfDocProxy);
                    showGlobalOptions();
                }
                
                document.getElementById('process-btn').disabled = false;
            } catch (err) {
                console.error(err);
                alert("Error loading file: " + err.message);
                openTool(currentTool.id); // Reset
            } finally {
                document.getElementById('processing-overlay').classList.add('hidden');
            }
        }

        async function handleTextToPdf(file) {
            const text = await file.text();
            const { PDFDocument, StandardFonts, rgb } = PDFLib;
            const pdfDoc = await PDFDocument.create();
            const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
            const fontSize = 12;
            const page = pdfDoc.addPage();
            const { width, height } = page.getSize();
            
            // Simple Line Wrapping Logic
            page.drawText(text, {
                x: 50,
                y: height - 50,
                size: fontSize,
                font: font,
                color: rgb(0, 0, 0),
                maxWidth: width - 100,
                lineHeight: 15,
            });

            const pdfBytes = await pdfDoc.save();
            // Now pretend we loaded this PDF
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            currentFile = new File([blob], "converted.pdf", { type: "application/pdf" });
            
            const arrayBuffer = await currentFile.arrayBuffer();
            pdfDocProxy = await pdfjsLib.getDocument(arrayBuffer).promise;
            await renderPreviewGrid(pdfDocProxy);
        }

        function renderSimpleFileList() {
            const container = document.getElementById('preview-container');
            const grid = document.getElementById('pages-grid');
            container.classList.remove('hidden');
            grid.className = "flex flex-col gap-2"; // Switch to list view
            
            currentFiles.forEach(file => {
                grid.innerHTML += `
                    <div class="bg-white dark:bg-gray-700 p-4 rounded-lg flex justify-between items-center shadow-sm">
                        <span class="font-medium truncate">${file.name}</span>
                        <span class="text-sm text-gray-500">${(file.size/1024/1024).toFixed(2)} MB</span>
                    </div>
                `;
            });
            document.getElementById('page-count').textContent = `${currentFiles.length} Files`;
        }

        // --- PDF Rendering ---
        async function renderPreviewGrid(pdfDoc) {
            const grid = document.getElementById('pages-grid');
            grid.className = "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4";
            const container = document.getElementById('preview-container');
            container.classList.remove('hidden');
            document.getElementById('page-count').textContent = pdfDoc.numPages;
            
            pageStates = new Array(pdfDoc.numPages).fill(null).map(() => ({ rotation: 0, deleted: false, selected: false }));
            
            // Auto-select all for certain tools
            if (currentTool.id === 'pdfToJpg') {
                 // Default select all? Let's start empty and let user select, or select all.
                 // Let's select NONE by default so they can pick specific ones, or add a "Select All" button later.
            }

            // Limit preview render for performance if too many pages
            const maxPreview = 50; 
            
            for (let i = 1; i <= Math.min(pdfDoc.numPages, maxPreview); i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'page-container bg-white dark:bg-gray-800';
                wrapper.id = `page-${i}`;
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const overlay = document.createElement('div');
                overlay.className = 'page-overlay';
                
                if (currentTool.id === 'rotate') {
                    overlay.innerHTML = `
                        <button onclick="rotatePage(${i-1}, -90)" class="p-2 bg-white rounded-full hover:bg-gray-100 text-gray-800">‚Ü∫</button>
                        <button onclick="rotatePage(${i-1}, 90)" class="p-2 bg-white rounded-full hover:bg-gray-100 text-gray-800">‚Üª</button>
                    `;
                } else if (currentTool.id === 'delete') {
                    overlay.innerHTML = `<button onclick="toggleDelete(${i-1})" class="p-2 bg-red-500 rounded-full hover:bg-red-600 text-white">üóëÔ∏è</button>`;
                } else if (currentTool.id === 'split' || currentTool.id === 'pdfToJpg') {
                    wrapper.onclick = () => toggleSelect(i-1);
                    wrapper.style.cursor = 'pointer';
                    overlay.innerHTML = `<div class="text-white font-bold text-lg">Click to Select</div>`;
                }

                wrapper.appendChild(canvas);
                if (currentTool.mode === 'edit' || currentTool.mode === 'select') wrapper.appendChild(overlay);
                grid.appendChild(wrapper);

                const page = await pdfDoc.getPage(i);
                const viewport = page.getViewport({ scale: 0.4 });
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                await page.render({ canvasContext: ctx, viewport: viewport }).promise;
            }
        }

        // --- Interactions ---
        function rotatePage(index, angle) {
            const state = pageStates[index];
            state.rotation = (state.rotation + angle) % 360;
            const el = document.getElementById(`page-${index+1}`).querySelector('canvas');
            el.style.transform = `rotate(${state.rotation}deg)`;
        }

        function toggleDelete(index) {
            const state = pageStates[index];
            state.deleted = !state.deleted;
            const el = document.getElementById(`page-${index+1}`);
            state.deleted ? el.classList.add('deleted') : el.classList.remove('deleted');
        }

        function toggleSelect(index) {
            const state = pageStates[index];
            state.selected = !state.selected;
            const el = document.getElementById(`page-${index+1}`);
            state.selected ? el.classList.add('selected') : el.classList.remove('selected');
        }

        function showGlobalOptions() {
            const container = document.getElementById('global-options');
            container.innerHTML = '';
            
            if (currentTool.id === 'protect') {
                container.innerHTML = `<label class="block font-medium mb-2">Set Password</label><input type="password" id="opt-pass" class="w-full p-3 rounded-lg border dark:bg-gray-700 dark:border-gray-600">`;
                container.classList.remove('hidden');
            } else if (currentTool.id === 'watermark') {
                container.innerHTML = `<label class="block font-medium mb-2">Watermark Text</label><input type="text" id="opt-water" value="CONFIDENTIAL" class="w-full p-3 rounded-lg border dark:bg-gray-700 dark:border-gray-600">`;
                container.classList.remove('hidden');
            }
        }

        // --- Core Processing ---
        const processBtn = document.getElementById('process-btn');
        processBtn.onclick = async () => {
            const overlay = document.getElementById('processing-overlay');
            overlay.classList.remove('hidden');
            document.getElementById('processing-text').textContent = "Processing...";

            try {
                // --- Feature: PDF to JPG (Using ZIP) ---
                if (currentTool.id === 'pdfToJpg') {
                    const zip = new JSZip();
                    const selectedIndices = pageStates.map((s, i) => s.selected ? i : -1).filter(i => i !== -1);
                    
                    if (selectedIndices.length === 0) throw new Error("No pages selected! Please click pages to select them.");

                    for (const idx of selectedIndices) {
                        const page = await pdfDocProxy.getPage(idx + 1);
                        const viewport = page.getViewport({ scale: 2.0 }); // High Quality
                        const canvas = document.createElement('canvas');
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        await page.render({ canvasContext: canvas.getContext('2d'), viewport: viewport }).promise;
                        
                        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.9));
                        zip.file(`page-${idx + 1}.jpg`, blob);
                    }
                    
                    const zipContent = await zip.generateAsync({ type: "blob" });
                    saveAs(zipContent, "pdf_images.zip");
                    closeModal();
                    return;
                }

                // --- Feature: PDF to Text ---
                if (currentTool.id === 'pdfToText') {
                    let fullText = "";
                    for (let i = 1; i <= pdfDocProxy.numPages; i++) {
                        const page = await pdfDocProxy.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        fullText += `--- Page ${i} ---\n${pageText}\n\n`;
                    }
                    const blob = new Blob([fullText], { type: "text/plain;charset=utf-8" });
                    saveAs(blob, "extracted_text.txt");
                    closeModal();
                    return;
                }

                // --- Feature: PDF Manipulations (PDF-Lib) ---
                const { PDFDocument, rgb, degrees, StandardFonts } = PDFLib;
                let newPdf;

                if (currentTool.id === 'merge') {
                    newPdf = await PDFDocument.create();
                    for (const file of currentFiles) {
                        const bytes = await file.arrayBuffer();
                        const srcDoc = await PDFDocument.load(bytes, { ignoreEncryption: true });
                        const copied = await newPdf.copyPages(srcDoc, srcDoc.getPageIndices());
                        copied.forEach(p => newPdf.addPage(p));
                    }
                } else {
                    // Single File Modification
                    const fileBuffer = await currentFile.arrayBuffer();
                    const srcDoc = await PDFDocument.load(fileBuffer, { ignoreEncryption: true });
                    newPdf = await PDFDocument.create();
                    
                    const pageIndices = srcDoc.getPageIndices();
                    let indicesToCopy = [];

                    if (currentTool.id === 'split') {
                        indicesToCopy = pageIndices.filter((_, idx) => pageStates[idx].selected);
                        if (indicesToCopy.length === 0) throw new Error("No pages selected!");
                    } else if (currentTool.id === 'delete') {
                        indicesToCopy = pageIndices.filter((_, idx) => !pageStates[idx].deleted);
                    } else {
                        indicesToCopy = pageIndices; // Keep all
                    }

                    const copiedPages = await newPdf.copyPages(srcDoc, indicesToCopy);
                    
                    for (let i = 0; i < copiedPages.length; i++) {
                        const page = copiedPages[i];
                        const originalIndex = indicesToCopy[i];
                        const state = pageStates[originalIndex];

                        if (state && state.rotation !== 0) {
                            page.setRotation(degrees(page.getRotation().angle + state.rotation));
                        }

                        if (currentTool.id === 'watermark') {
                            const text = document.getElementById('opt-water').value;
                            const { width, height } = page.getSize();
                            page.drawText(text, { x: width/4, y: height/2, size: 50, color: rgb(0.5, 0.5, 0.5), opacity: 0.4, rotate: degrees(45) });
                        }

                        if (currentTool.id === 'pageNumber') {
                            const font = await newPdf.embedFont(StandardFonts.Helvetica);
                            const text = `${i + 1}`;
                            const { width } = page.getSize();
                            const textWidth = font.widthOfTextAtSize(text, 12);
                            page.drawText(text, { x: width/2 - textWidth/2, y: 20, size: 12, font, color: rgb(0,0,0) });
                        }

                        newPdf.addPage(page);
                    }

                    if (currentTool.id === 'protect') {
                        const pass = document.getElementById('opt-pass').value;
                        if(pass) await newPdf.encrypt({ userPassword: pass, ownerPassword: pass });
                    }
                }

                const pdfBytes = await newPdf.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                saveAs(blob, "edited_document.pdf");
                closeModal();

            } catch (err) {
                console.error(err);
                alert("Error: " + err.message);
            } finally {
                overlay.classList.add('hidden');
            }
        };

        // --- Dark Mode ---
        document.getElementById('dark-mode-toggle').onclick = () => document.documentElement.classList.toggle('dark');
    </script>
</body>
</html>
